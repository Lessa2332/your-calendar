<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Magical Ukraine Calendar 2026</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="icon" href="data:image/x-icon;base64,AAABAAEAEBAQAAAAAAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAP//AP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAT/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAABAAEDAREAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBgaEII0KxwRVS0fAkM2JyggkKFhcYGRolJnicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK">
  
  <style>
    * { 
      box-sizing: border-box; 
      margin: 0; 
      padding: 0; 
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, sans-serif;
      touch-action: none;
      position: fixed;
    }
    
    #mindar-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      background: #000;
    }
    
    #ui {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: env(safe-area-inset-top, 0px) env(safe-area-inset-right, 0px)
                env(safe-area-inset-bottom, 0px) env(safe-area-inset-left, 0px);
    }
    
    #info {
      text-align: center;
      color: white;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
      padding: 12px 16px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 16px;
      font-size: clamp(14px, 4vw, 18px);
      line-height: 1.4;
      max-width: 90%;
      margin: 0 auto;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(0, 255, 255, 0.3);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }
    
    #top-bar {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: max(12px, env(safe-area-inset-top, 12px)) 12px 0;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .lang-btn, .etsy-btn {
      pointer-events: auto;
      background: rgba(0, 200, 255, 0.25);
      border: 1px solid rgba(0, 255, 255, 0.6);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
    }
    
    .lang-btn:hover, .etsy-btn:hover {
      background: rgba(0, 200, 255, 0.4);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 255, 255, 0.3);
    }
    
    #crystals {
      display: flex;
      gap: clamp(6px, 2.5vw, 12px);
      justify-content: center;
      padding: 0 8px max(20px, env(safe-area-inset-bottom, 20px));
      flex-wrap: wrap;
    }
    
    .crystal-slot {
      width: clamp(36px, 10vw, 52px);
      height: clamp(36px, 10vw, 52px);
      border: 2px solid rgba(0, 255, 255, 0.5);
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(20px, 6vw, 32px);
      color: white;
      transition: all 0.3s ease;
      backdrop-filter: blur(4px);
    }
    
    .crystal-slot.collected {
      background: linear-gradient(135deg, #00ffff, #ff00ff);
      border-color: #ffffff;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: white;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid #00ffff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .error-message {
      background: rgba(255, 0, 0, 0.8);
      color: white;
      padding: 16px;
      border-radius: 12px;
      text-align: center;
      max-width: 80%;
      margin: 20px auto;
    }

    .voice-btn {
      position: absolute;
      bottom: 100px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(0, 200, 255, 0.25);
      border: 1px solid rgba(0, 255, 255, 0.6);
      color: white;
      cursor: pointer;
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      pointer-events: auto;
    }

    .demo-content {
      display: none;
      text-align: center;
      color: white;
      padding: 20px;
    }

    .demo-image {
      max-width: 200px;
      border-radius: 12px;
      margin: 10px;
      border: 2px solid #00ffff;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="mindar-container"></div>
  <div id="ui">
    <div id="top-bar">
      <button class="lang-btn" id="lang-toggle" aria-label="Toggle language">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞</button>
      <a class="etsy-btn" id="etsy-link" href="https://smartlessa.etsy.com" target="_blank" rel="noopener" aria-label="Visit our Etsy shop">Shop on Etsy</a>
    </div>
    <div id="info">Point your camera at any calendar marker ‚ù§Ô∏è</div>
    <div id="crystals"></div>
  </div>

  <div class="loading-overlay" id="loading">
    <div class="loading-spinner"></div>
    <div id="loading-text">Loading AR Experience...</div>
  </div>

  <button class="voice-btn" id="voice-toggle" aria-label="Toggle voiceover" style="display: none;">üîä</button>

  <div id="demo-content" class="demo-content">
    <h3>üé® Interactive Calendar Demo</h3>
    <p>AR is loading... Here's a preview:</p>
    <div id="demo-images"></div>
    <button class="retry-btn" onclick="retryAR()">Try AR Again</button>
  </div>

  <script type="module">
    // Main application
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
    import { MindARThree } from 'https://cdn.jsdelivr.net/npm/mind-ar@1.2.3/dist/mindar-image-three.prod.js';

    class MagicalCalendar {
      constructor() {
        this.mindarThree = null;
        this.renderer = null;
        this.scene = null;
        this.camera = null;
        this.arGroups = [];
        this.currentLang = localStorage.getItem('calendar-lang') || 'en';
        this.collectedCrystals = JSON.parse(localStorage.getItem('ua-crystals2026') || '[]');
        this.isARRunning = false;
        this.currentTarget = -1;
        
        this.translations = {
          en: {
            infoScan: "Point your camera at any calendar marker ‚ù§Ô∏è",
            infoComplete: "UKRAINE'S HEART IS COMPLETE!<br>You are a true hero ‚ù§Ô∏è",
            langBtn: "–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞",
            etsyBtn: "Shop on Etsy",
            loading: "Loading AR Experience...",
            errorCamera: "‚ùå Camera access denied. Please allow camera permissions and refresh.",
            errorAR: "‚ùå AR loading failed. Showing demo mode...",
            voiceOn: "Voice guidance enabled",
            voiceOff: "Voice guidance disabled"
          },
          uk: {
            infoScan: "–ù–∞–≤–µ–¥–∏ –∫–∞–º–µ—Ä—É –Ω–∞ –±—É–¥—å-—è–∫–∏–π –º–∞—Ä–∫–µ—Ä –∫–∞–ª–µ–Ω–¥–∞—Ä—è ‚ù§Ô∏è",
            infoComplete: "–°–ï–†–¶–ï –£–ö–†–ê–á–ù–ò –ó–Ü–ë–†–ê–ù–û!<br>–¢–∏ ‚Äî —Å–ø—Ä–∞–≤–∂–Ω—ñ–π –≥–µ—Ä–æ–π ‚ù§Ô∏è",
            langBtn: "English",
            etsyBtn: "–ö—É–ø–∏—Ç–∏ –Ω–∞ Etsy",
            loading: "–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è AR...",
            errorCamera: "‚ùå –î–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏ –∑–∞–±–æ—Ä–æ–Ω–µ–Ω–æ. –î–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø —Ç–∞ –æ–Ω–æ–≤—ñ—Ç—å —Å—Ç–æ—Ä—ñ–Ω–∫—É.",
            errorAR: "‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è AR. –ü–æ–∫–∞–∑—É—î–º–æ –¥–µ–º–æ-—Ä–µ–∂–∏–º...",
            voiceOn: "–ì–æ–ª–æ—Å–æ–≤–µ –∫–µ—Ä—É–≤–∞–Ω–Ω—è —É–≤—ñ–º–∫–Ω–µ–Ω–æ",
            voiceOff: "–ì–æ–ª–æ—Å–æ–≤–µ –∫–µ—Ä—É–≤–∞–Ω–Ω—è –≤–∏–º–∫–Ω–µ–Ω–æ"
          }
        };

        this.init();
      }

      async init() {
        try {
          this.initializeUI();
          this.initializeVoice();
          await this.initializeAR();
          this.isInitialized = true;
          this.hideLoading();
        } catch (error) {
          console.error('App initialization failed:', error);
          this.showError(this.translations[this.currentLang].errorAR, true);
          this.initializeDemoMode();
        }
      }

      initializeUI() {
        this.updateUIText();
        this.updateCrystalsUI();
        this.setupEventListeners();
      }

      updateUIText() {
        const t = this.translations[this.currentLang];
        document.getElementById('info').innerHTML = t.infoScan;
        document.getElementById('lang-toggle').textContent = t.langBtn;
        document.getElementById('etsy-link').textContent = t.etsyBtn;
        document.getElementById('loading-text').textContent = t.loading;
      }

      updateCrystalsUI() {
        const container = document.getElementById('crystals');
        container.innerHTML = '';
        for (let i = 0; i < 12; i++) {
          const div = document.createElement('div');
          div.className = 'crystal-slot' + (this.collectedCrystals.includes(i) ? ' collected' : '');
          div.innerHTML = this.collectedCrystals.includes(i) ? '‚ú¶' : (i + 1);
          div.setAttribute('aria-label', `Month ${i + 1} ${this.collectedCrystals.includes(i) ? 'collected' : 'not collected'}`);
          container.appendChild(div);
        }
      }

      setupEventListeners() {
        document.getElementById('lang-toggle').addEventListener('click', () => {
          this.currentLang = this.currentLang === 'en' ? 'uk' : 'en';
          localStorage.setItem('calendar-lang', this.currentLang);
          this.updateUIText();
        });

        window.addEventListener('resize', () => this.onWindowResize());
        window.addEventListener('orientationchange', () => {
          setTimeout(() => this.onWindowResize(), 300);
        });
      }

      async initializeAR() {
        this.mindarThree = new MindARThree({
          container: document.getElementById('mindar-container'),
          imageTargetSrc: 'calendar.mind',
          maxTrack: 3,
          filterMinCF: 0.001,
          filterBeta: 0.01,
          warmupTolerance: 8,
          missTolerance: 12
        });

        ({ renderer: this.renderer, scene: this.scene, camera: this.camera } = this.mindarThree);
        
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.outputEncoding = THREE.sRGBEncoding;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(1, 1, 1);
        this.scene.add(ambientLight, directionalLight);

        // Create anchor groups
        this.arGroups = [];
        for (let i = 0; i < 12; i++) {
          const group = new THREE.Group();
          const targetGroup = this.mindarThree.addAnchor(i);
          targetGroup.group.add(group);
          this.arGroups.push(group);
        }

        await this.mindarThree.start();
        this.isARRunning = true;
        this.animate();
      }

      animate() {
        if (!this.isARRunning) return;
        
        this.renderer.render(this.scene, this.camera);
        
        let visibleTarget = -1;
        for (let i = 0; i < 12; i++) {
          if (this.arGroups[i] && this.arGroups[i].visible) {
            visibleTarget = i;
            break;
          }
        }
        
        if (visibleTarget !== this.currentTarget) {
          if (this.currentTarget !== -1) {
            this.clearTargetGroup(this.currentTarget);
          }
          if (visibleTarget !== -1) {
            setTimeout(() => this.handleTargetFound(visibleTarget), 100);
          }
          this.currentTarget = visibleTarget;
        }
        
        requestAnimationFrame(() => this.animate());
      }

      clearTargetGroup(index) {
        const group = this.arGroups[index];
        if (group) {
          while (group.children.length > 0) {
            const child = group.children[0];
            if (child.material) child.material.dispose();
            if (child.geometry) child.geometry.dispose();
            group.remove(child);
          }
        }
      }

      handleTargetFound(targetIndex) {
        if (this.collectedCrystals.includes(targetIndex)) {
          this.showCrystalReward(targetIndex);
        } else {
          this.showMonthContent(targetIndex);
        }
      }

      showMonthContent(monthIndex) {
        const group = this.arGroups[monthIndex];
        if (!group) return;

        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          const texture = new THREE.Texture(img);
          texture.needsUpdate = true;
          
          const aspect = img.width / img.height;
          const size = Math.min(1.4, window.innerWidth / 1000 * 1.4);
          const geometry = new THREE.PlaneGeometry(size, size / aspect);
          
          const material = new THREE.MeshBasicMaterial({ 
            map: texture,
            transparent: true,
            opacity: 0.9
          });
          
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.z = 0.01;
          group.add(mesh);
          
          const handleClick = () => {
            this.startPuzzleInteraction(monthIndex, texture, group, size, size / aspect);
            this.renderer.domElement.removeEventListener('click', handleClick);
          };
          
          this.renderer.domElement.addEventListener('click', handleClick);
        };
        
        // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ JPG –¥–ª—è –≤—Å—ñ—Ö –º—ñ—Å—è—Ü—ñ–≤
        const monthNumber = (monthIndex + 1).toString().padStart(2, '0');
        img.src = `images/${monthNumber}.jpg`;
      }

      startPuzzleInteraction(monthIndex, texture, group, width, height) {
        // Enhanced puzzle with drag and drop
        const puzzlePieces = this.createPuzzlePieces(texture, width, height);
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        let selectedPiece = null;

        puzzlePieces.forEach(piece => group.add(piece));

        const onPointerDown = (event) => {
          const rect = this.renderer.domElement.getBoundingClientRect();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
          
          raycaster.setFromCamera(mouse, this.camera);
          const intersects = raycaster.intersectObjects(puzzlePieces);
          
          if (intersects.length > 0) {
            selectedPiece = intersects[0].object;
          }
        };

        const onPointerMove = (event) => {
          if (!selectedPiece) return;
          
          const rect = this.renderer.domElement.getBoundingClientRect();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
          
          raycaster.setFromCamera(mouse, this.camera);
          const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
          const targetPosition = new THREE.Vector3();
          raycaster.ray.intersectPlane(plane, targetPosition);
          
          selectedPiece.position.copy(targetPosition);
        };

        const onPointerUp = () => {
          if (selectedPiece) {
            this.checkPuzzleCompletion(puzzlePieces, group, monthIndex);
            selectedPiece = null;
          }
        };

        const domElement = this.renderer.domElement;
        domElement.addEventListener('pointerdown', onPointerDown);
        domElement.addEventListener('pointermove', onPointerMove);
        domElement.addEventListener('pointerup', onPointerUp);

        // Store references for cleanup
        group.userData.puzzleEvents = { onPointerDown, onPointerMove, onPointerUp };
      }

      createPuzzlePieces(texture, width, height) {
        const pieces = [];
        const gridSize = 3;
        const pieceWidth = width / gridSize;
        const pieceHeight = height / gridSize;

        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            const geometry = new THREE.PlaneGeometry(pieceWidth * 0.95, pieceHeight * 0.95);
            const material = new THREE.MeshBasicMaterial({ 
              map: texture,
              transparent: true
            });
            
            const piece = new THREE.Mesh(geometry, material);
            piece.position.set(
              (x - gridSize/2 + 0.5) * pieceWidth + (Math.random() - 0.5) * pieceWidth,
              (gridSize/2 - y - 0.5) * pieceHeight + (Math.random() - 0.5) * pieceHeight,
              0.02
            );
            
            piece.userData = {
              correctX: (x - gridSize/2 + 0.5) * pieceWidth,
              correctY: (gridSize/2 - y - 0.5) * pieceHeight
            };
            
            pieces.push(piece);
          }
        }
        
        return pieces;
      }

      checkPuzzleCompletion(pieces, group, monthIndex) {
        const tolerance = 0.1;
        const allCorrect = pieces.every(piece => {
          const distance = piece.position.distanceTo(
            new THREE.Vector3(piece.userData.correctX, piece.userData.correctY, 0.02)
          );
          return distance < tolerance;
        });

        if (allCorrect) {
          // Clean up event listeners
          const events = group.userData.puzzleEvents;
          if (events) {
            const domElement = this.renderer.domElement;
            domElement.removeEventListener('pointerdown', events.onPointerDown);
            domElement.removeEventListener('pointermove', events.onPointerMove);
            domElement.removeEventListener('pointerup', events.onPointerUp);
          }
          
          group.clear();
          this.collectCrystal(monthIndex);
          this.showCrystalReward(monthIndex);
          this.createParticleEffect(group);
        }
      }

      collectCrystal(monthIndex) {
        if (!this.collectedCrystals.includes(monthIndex)) {
          this.collectedCrystals.push(monthIndex);
          localStorage.setItem('ua-crystals2026', JSON.stringify(this.collectedCrystals));
          this.updateCrystalsUI();
          
          if (this.collectedCrystals.length === 12) {
            document.getElementById('info').innerHTML = this.translations[this.currentLang].infoComplete;
          }
        }
      }

      showCrystalReward(monthIndex) {
        const group = this.arGroups[monthIndex];
        if (!group) return;
        
        group.clear();
        
        const colors = [0x00ffff, 0xff00ff, 0x00ff00, 0xffff00, 0xff8800, 0xff0066,
                      0x0066ff, 0xff3399, 0x33ff99, 0xffcc00, 0xcc00ff, 0x00ccff];
        
        const geometry = new THREE.IcosahedronGeometry(0.3, 2);
        const material = new THREE.MeshPhysicalMaterial({
          color: colors[monthIndex],
          transmission: 0.8,
          roughness: 0.1,
          metalness: 0.9
        });
        
        const crystal = new THREE.Mesh(geometry, material);
        group.add(crystal);
        
        const animate = () => {
          if (crystal.parent) {
            crystal.rotation.y += 0.02;
            crystal.rotation.x += 0.01;
            requestAnimationFrame(animate);
          }
        };
        animate();
      }

      createParticleEffect(group) {
        const particleCount = 50;
        const positions = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] = (Math.random() - 0.5) * 2;
          positions[i * 3 + 1] = (Math.random() - 0.5) * 2;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.PointsMaterial({
          size: 0.05,
          color: 0x00ffff,
          transparent: true,
          opacity: 0.8
        });
        
        const particles = new THREE.Points(geometry, material);
        group.add(particles);
      }

      initializeVoice() {
        const voiceButton = document.getElementById('voice-toggle');
        if ('speechSynthesis' in window) {
          voiceButton.style.display = 'flex';
          
          voiceButton.addEventListener('click', () => {
            const t = this.translations[this.currentLang];
            const utterance = new SpeechSynthesisUtterance(
              voiceButton.textContent === 'üîä' ? t.infoScan : t.voiceOff
            );
            utterance.lang = this.currentLang === 'en' ? 'en-US' : 'uk-UA';
            window.speechSynthesis.speak(utterance);
            
            voiceButton.textContent = voiceButton.textContent === 'üîä' ? 'üîá' : 'üîä';
          });
        }
      }

      initializeDemoMode() {
        const demoContent = document.getElementById('demo-content');
        demoContent.style.display = 'block';
        
        const demoImages = document.getElementById('demo-images');
        for (let i = 0; i < 3; i++) {
          const img = document.createElement('img');
          img.className = 'demo-image';
          img.src = `images/${(i + 1).toString().padStart(2, '0')}.jpg`;
          img.alt = `Month ${i + 1}`;
          img.onclick = () => this.collectCrystal(i);
          demoImages.appendChild(img);
        }
        
        document.getElementById('info').innerHTML = this.translations[this.currentLang].infoScan + 
          "<br><small>Demo Mode - Click images to collect crystals!</small>";
      }

      onWindowResize() {
        if (this.camera && this.renderer) {
          const width = window.innerWidth;
          const height = window.innerHeight;
          
          this.camera.aspect = width / height;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(width, height);
        }
      }

      hideLoading() {
        const loading = document.getElementById('loading');
        if (loading) {
          loading.style.opacity = '0';
          setTimeout(() => loading.style.display = 'none', 300);
        }
      }

      showError(message, showRetry = false) {
        this.hideLoading();
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.innerHTML = message + 
          (showRetry ? `<br><button class="retry-btn" onclick="window.calendarApp.retryAR()">Retry AR</button>` : '');
        document.body.appendChild(errorDiv);
      }

      retryAR() {
        document.querySelectorAll('.error-message').forEach(el => el.remove());
        document.getElementById('demo-content').style.display = 'none';
        
        const loading = document.getElementById('loading');
        loading.style.display = 'flex';
        loading.style.opacity = '1';
        
        setTimeout(() => {
          if (this.mindarThree) {
            this.mindarThree.stop();
          }
          this.init();
        }, 500);
      }
    }

    // Initialize app
    document.addEventListener('DOMContentLoaded', () => {
      window.calendarApp = new MagicalCalendar();
    });

    // Global functions for HTML onclick
    window.retryAR = () => window.calendarApp.retryAR();
  </script>
</body>
</html>
