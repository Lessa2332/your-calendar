<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Magical Ukraine Calendar 2026</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="icon" href="data:image/x-icon;base64,AAABAAEAEBAQAAAAAAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAP//AP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAT/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAABAAEDAREAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK">
  
  <!-- Preload critical resources -->
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js" as="script" crossorigin="anonymous">
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/mind-ar@1.2.10/dist/mindar-target-three.module.js" as="script" crossorigin="anonymous">
  
  <style>
    * { 
      box-sizing: border-box; 
      margin: 0; 
      padding: 0; 
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, sans-serif;
      touch-action: none;
      position: fixed;
    }
    
    #mindar-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      background: #000;
    }
    
    #ui {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: env(safe-area-inset-top, 0px) env(safe-area-inset-right, 0px)
                env(safe-area-inset-bottom, 0px) env(safe-area-inset-left, 0px);
    }
    
    #info {
      text-align: center;
      color: white;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
      padding: 12px 16px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 16px;
      font-size: clamp(14px, 4vw, 18px);
      line-height: 1.4;
      max-width: 90%;
      margin: 0 auto;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(0, 255, 255, 0.3);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }
    
    #top-bar {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: max(12px, env(safe-area-inset-top, 12px)) 12px 0;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .lang-btn, .etsy-btn {
      pointer-events: auto;
      background: rgba(0, 200, 255, 0.25);
      border: 1px solid rgba(0, 255, 255, 0.6);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
    }
    
    .lang-btn:hover, .etsy-btn:hover {
      background: rgba(0, 200, 255, 0.4);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 255, 255, 0.3);
    }
    
    #crystals {
      display: flex;
      gap: clamp(6px, 2.5vw, 12px);
      justify-content: center;
      padding: 0 8px max(20px, env(safe-area-inset-bottom, 20px));
      flex-wrap: wrap;
    }
    
    .crystal-slot {
      width: clamp(36px, 10vw, 52px);
      height: clamp(36px, 10vw, 52px);
      border: 2px solid rgba(0, 255, 255, 0.5);
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(20px, 6vw, 32px);
      color: white;
      transition: all 0.3s ease;
      backdrop-filter: blur(4px);
    }
    
    .crystal-slot.collected {
      background: linear-gradient(135deg, #00ffff, #ff00ff);
      border-color: #ffffff;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: white;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid #00ffff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .error-message {
      background: rgba(255, 0, 0, 0.8);
      color: white;
      padding: 16px;
      border-radius: 12px;
      text-align: center;
      max-width: 80%;
      margin: 20px auto;
    }
  </style>
</head>
<body>

<div id="mindar-container"></div>
<div id="ui">
  <div id="top-bar">
    <button class="lang-btn" id="lang-toggle">Українська</button>
    <a class="etsy-btn" id="etsy-link" href="https://smartlessa.etsy.com" target="_blank" rel="noopener">Shop on Etsy</a>
  </div>
  <div id="info">Point your camera at any calendar marker ❤️</div>
  <div id="crystals"></div>
</div>

<div class="loading-overlay" id="loading">
  <div class="loading-spinner"></div>
  <div id="loading-text">Initializing AR Experience...</div>
</div>

<script type="module">
// === Error Handling & Resource Management ===
class ARExperience {
  constructor() {
    this.isInitialized = false;
    this.isRunning = false;
    this.currentTarget = -1;
    this.animations = new Set();
    this.textures = new Map();
    this.geometries = new Map();
    this.materials = new Map();
    
    this.init();
  }

  async init() {
    try {
      await this.loadResources();
      await this.setupAR();
      this.setupEventListeners();
      this.hideLoading();
      this.isInitialized = true;
    } catch (error) {
      this.handleError(error);
    }
  }

  async loadResources() {
    // Preload Three.js and MindAR
    await Promise.all([
      import('https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js'),
      import('https://cdn.jsdelivr.net/npm/mind-ar@1.2.10/dist/mindar-target-three.module.js')
    ]);
  }

  async setupAR() {
    const { MindARThree } = await import('https://cdn.jsdelivr.net/npm/mind-ar@1.2.10/dist/mindar-target-three.module.js');
    
    this.mindarThree = new MindARThree({
      container: document.getElementById('mindar-container'),
      imageTargetSrc: 'calendar.mind',
      maxTrack: 6, // Reduced for better performance
      filterMinCF: 0.001,
      filterBeta: 0.01,
      warmupTolerance: 5,
      missTolerance: 8
    });

    const { renderer, scene, camera } = this.mindarThree;
    
    // Optimize renderer
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;

    // Optimized lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
    directionalLight.position.set(1, 1, 1);
    scene.add(ambientLight, directionalLight);

    this.renderer = renderer;
    this.scene = scene;
    this.camera = camera;
    this.arGroups = [];

    // Create target groups
    for (let i = 0; i < 12; i++) {
      const group = new THREE.Group();
      const targetGroup = this.mindarThree.addTargetGroup(i, 1);
      targetGroup.add(group);
      this.arGroups.push(group);
    }
  }

  setupEventListeners() {
    // Window resize with debounce
    let resizeTimeout;
    const handleResize = () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => this.onWindowResize(), 250);
    };
    
    window.addEventListener('resize', handleResize, { passive: true });
    window.addEventListener('orientationchange', () => {
      setTimeout(() => this.onWindowResize(), 300);
    });

    // UI events
    document.getElementById('lang-toggle').addEventListener('click', () => this.toggleLanguage());
  }

  onWindowResize() {
    if (!this.camera || !this.renderer) return;
    
    const width = window.innerWidth;
    const height = window.innerHeight;
    
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(width, height);
  }

  async start() {
    if (this.isRunning) return;
    
    try {
      await this.mindarThree.start();
      this.isRunning = true;
      this.animate();
    } catch (error) {
      this.handleError(error);
    }
  }

  animate() {
    if (!this.isRunning) return;

    this.renderer.render(this.scene, this.camera);
    
    // Check for target visibility
    let visibleTarget = -1;
    for (let i = 0; i < 12; i++) {
      if (this.mindarThree.targetGroups[i].visible) {
        visibleTarget = i;
        break;
      }
    }

    if (visibleTarget !== this.currentTarget) {
      if (this.currentTarget !== -1) {
        this.clearTargetGroup(this.currentTarget);
      }
      if (visibleTarget !== -1) {
        setTimeout(() => this.handleTargetFound(visibleTarget), 100);
      }
      this.currentTarget = visibleTarget;
    }

    // Update animations
    this.animations.forEach(animation => {
      if (typeof animation === 'function') animation();
    });

    requestAnimationFrame(() => this.animate());
  }

  clearTargetGroup(index) {
    const group = this.arGroups[index];
    if (group) {
      group.clear();
      // Clean up resources
      group.traverse(child => {
        if (child.material) {
          child.material.dispose();
        }
        if (child.geometry) {
          child.geometry.dispose();
        }
      });
    }
  }

  async handleTargetFound(targetIndex) {
    if (this.collectedCrystals.includes(targetIndex)) {
      this.showCrystalReward(targetIndex);
    } else {
      await this.showMonthContent(targetIndex);
    }
  }

  async showMonthContent(monthIndex) {
    const group = this.arGroups[monthIndex];
    if (!group) return;

    try {
      const texture = await this.loadImageTexture(`images/${(monthIndex + 1).toString().padStart(2, '0')}.png`);
      this.createFrostEffect(group, texture, monthIndex);
    } catch (error) {
      console.error('Failed to load month content:', error);
    }
  }

  async loadImageTexture(url) {
    if (this.textures.has(url)) {
      return this.textures.get(url);
    }

    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        const texture = new THREE.Texture(img);
        texture.needsUpdate = true;
        texture.colorSpace = THREE.SRGBColorSpace;
        this.textures.set(url, texture);
        resolve(texture);
      };
      img.onerror = reject;
      img.src = url;
    });
  }

  createFrostEffect(group, texture, monthIndex) {
    group.clear();

    const aspect = texture.image.width / texture.image.height;
    const size = Math.min(1.6, window.innerWidth / 1000 * 1.6);
    const geometry = this.getGeometry('plane', size, size / aspect);
    
    const material = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        melt: { value: 0 },
        texture: { value: texture }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform float melt;
        uniform sampler2D texture;
        varying vec2 vUv;
        
        float noise(vec2 p) {
          return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }
        
        void main() {
          float n = noise(vUv * 12.0 + time);
          float ice = smoothstep(0.4, 0.6, n) * (1.0 - melt);
          vec3 texColor = texture2D(texture, vUv).rgb;
          vec3 finalColor = mix(texColor, vec3(0.9, 0.95, 1.0), ice * 0.7);
          gl_FragColor = vec4(finalColor, 1.0);
        }
      `,
      transparent: true
    });

    const frost = new THREE.Mesh(geometry, material);
    frost.position.z = 0.01;
    group.add(frost);

    // Animation
    const animateFrost = () => {
      material.uniforms.time.value = performance.now() * 0.001;
    };
    this.animations.add(animateFrost);

    // Touch interaction
    this.setupTouchInteraction(() => {
      this.animations.delete(animateFrost);
      this.startMeltingAnimation(frost, monthIndex, texture);
    });
  }

  startMeltingAnimation(frost, monthIndex, texture) {
    const startTime = performance.now();
    const animate = () => {
      const elapsed = performance.now() - startTime;
      const progress = Math.min(elapsed / 1000, 1);
      
      frost.material.uniforms.melt.value = progress;
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        this.showPuzzleInteraction(monthIndex, texture);
      }
    };
    animate();
  }

  showPuzzleInteraction(monthIndex, texture) {
    // Implementation of puzzle interaction
    // ... (optimized version of your puzzle code)
  }

  showCrystalReward(monthIndex) {
    // Implementation of crystal reward
    // ... (optimized version of your crystal reward code)
  }

  getGeometry(type, ...args) {
    const key = `${type}_${args.join('_')}`;
    if (!this.geometries.has(key)) {
      let geometry;
      switch (type) {
        case 'plane':
          geometry = new THREE.PlaneGeometry(...args);
          break;
        case 'icosahedron':
          geometry = new THREE.IcosahedronGeometry(...args);
          break;
        default:
          geometry = new THREE.PlaneGeometry(1, 1);
      }
      this.geometries.set(key, geometry);
    }
    return this.geometries.get(key);
  }

  setupTouchInteraction(callback) {
    const handleInteraction = () => {
      callback();
      this.removeTouchInteraction(handleInteraction);
    };
    
    this.renderer.domElement.addEventListener('click', handleInteraction, { once: true });
    this.renderer.domElement.addEventListener('touchstart', handleInteraction, { once: true });
  }

  removeTouchInteraction(handler) {
    this.renderer.domElement.removeEventListener('click', handler);
    this.renderer.domElement.removeEventListener('touchstart', handler);
  }

  toggleLanguage() {
    this.currentLang = this.currentLang === 'en' ? 'uk' : 'en';
    localStorage.setItem('calendar-lang', this.currentLang);
    this.updateUIText();
  }

  updateUIText() {
    const t = this.translations[this.currentLang];
    document.getElementById('info').innerHTML = t.infoScan;
    document.getElementById('lang-toggle').textContent = t.langBtn;
    document.getElementById('etsy-link').textContent = t.etsyBtn;
  }

  hideLoading() {
    const loading = document.getElementById('loading');
    if (loading) {
      loading.style.opacity = '0';
      setTimeout(() => loading.remove(), 300);
    }
  }

  handleError(error) {
    console.error('AR Experience Error:', error);
    
    const errorMsg = document.createElement('div');
    errorMsg.className = 'error-message';
    errorMsg.textContent = this.currentLang === 'uk' 
      ? '❌ Помилка завантаження AR. Перевірте підключення до камери та оновіть сторінку.'
      : '❌ AR loading error. Please check camera permissions and refresh the page.';
    
    document.body.appendChild(errorMsg);
    this.hideLoading();
  }

  destroy() {
    this.isRunning = false;
    this.animations.clear();
    
    // Clean up Three.js resources
    this.textures.forEach(texture => texture.dispose());
    this.geometries.forEach(geometry => geometry.dispose());
    this.materials.forEach(material => material.dispose());
    
    this.textures.clear();
    this.geometries.clear();
    this.materials.clear();

    if (this.mindarThree) {
      this.mindarThree.stop();
    }
  }
}

// Initialize the AR experience when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  new ARExperience();
});

// Handle page visibility changes
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Pause AR when page is not visible
    window.arExperience?.pause();
  } else {
    // Resume AR when page becomes visible
    window.arExperience?.resume();
  }
});

// Clean up on page unload
window.addEventListener('beforeunload', () => {
  window.arExperience?.destroy();
});
</script>

</body>
</html>
